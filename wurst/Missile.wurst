package Missile
import TimerUtils
import Assets
import ClosureTimers


    

public interface MissileAction
    function run()




public class Missile

    private static let UPDATEFREQ = ANIMATION_PERIOD //ANIMATION_PERIOD

    private vec3 pos

    private vec3 velocity

    private real gravity

    private effect missileSfx

    private timer updateTimer

    private real targetZ

    private vec3 targetPos 
    
    private real speed

    private MissileAction action_OnFinish = null

    private real direction

    construct( vec3 originPos, vec3 targetPos, string sfx, real speed, real arc )

        this.targetPos = targetPos

        let distance = originPos.distanceTo(targetPos)
        let heightDif =  targetPos.z - originPos.z
        this.direction = originPos.angleTo2d(targetPos).radians()

        let adjustedSpeed = speed * UPDATEFREQ

        let time = distance / adjustedSpeed

        this.speed = adjustedSpeed
        targetZ = targetPos.z

        velocity = vec3( Cos(direction) * adjustedSpeed,
                         Sin(direction) * adjustedSpeed,
                         Tan(arc) * adjustedSpeed
        )

        gravity =  (2 / time) * (heightDif / time - velocity.z)
        

        print("Gravity: "+gravity.toString(5))
        
        //(2*heightDif + 2*velocity.z * time ) / (time*time)
        
        //(Sin(2*arc) * velocity.length()*velocity.length()) / distance
                              
        
        print(velocity.toString())

        pos = originPos

        missileSfx = addEffect( sfx, pos )
        ..setRoll(direction)

        // Timer
        updateTimer = getTimer()
        ..setData( this castTo int )
        ..startPeriodic( UPDATEFREQ, () -> GetExpiredTimer().getData() castTo thistype.update() ) 



    ondestroy

        updateTimer.release()
        missileSfx.destr()



    function update()


        let remainingDistance = pos.toVec2().distanceTo(targetPos.toVec2())

        if speed >= remainingDistance
            
            if action_OnFinish != null

                action_OnFinish.run()


            destroy this
            return

        else
            let heightDif =  targetPos.z - pos.z
            let time = remainingDistance / speed
            let gravity = (2 / time) * (heightDif / time - velocity.z)

            velocity.z += gravity
            pos += velocity

            missileSfx.setPos(pos)


            let angle = Atan( velocity.z / speed )

            print(direction)

            missileSfx.setPitch(-angle*Cos(direction))// * Sin(direction))
            missileSfx.setYaw(angle*Sin(direction))//) * )




        
    function addPeriodicAction(  )


    function onUnitCollision()


    function addActionOnCollision( boolean multipleCollisions, MissileAction action )      
        // Also activates collision detection


    function addOnFinishAction( MissileAction action )
        action_OnFinish = action

        
 
    function getPos() returns vec2
        return pos.toVec2()

    // function getPos3() returns vec3
    //     return pos




