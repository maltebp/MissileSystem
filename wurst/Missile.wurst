package Missile
import TimerUtils

    /*

        ProjectileTypes:
            - Unit Target
            - Unit Homing
            - Position

        Detections:
            - On hit (unit, position etc)
            - On Collision (perhaps using a filter function?)
    */


public interface MissileAction
    function run()


public interface MissileUnitAction
    function run(unit target)


public interface ProjectileFilter<T>
    function filter( T filterParam ) returns boolean


public class Missile

    use TimedLoop

    private static let UPDATEFREQ = ANIMATION_PERIOD //ANIMATION_PERIOD

    private vec3 pos

    private vec3 velocity

    private real gravity

    protected effect missileSfx


    private vec3 targetPos 
    
    private real speed
    
    private ProjectileFilter<unit> collisionFilter = null
    
    private real collisionRange = 0

    private boolean collisionEnabled = false

    private boolean collideOnce = false

    private group collidedUnits = null

    private MissileUnitAction action_OnCollision = null

    private MissileAction action_OnFinish = null

    private real direction

    private unit targetUnit = null

    private real zOffset = 0 // only used with unit target


    private real distanceToTravel = 0 // It will travel exactly this distanceToTravel

    private vec3 originPos

    protected MissileAction action_preUpdate = null
    protected MissileAction action_postUpdate = null


    construct( vec3 originPos, vec3 targetPos, string sfxPath, real speed, real arc )
        initialize(originPos, targetPos, sfxPath, speed, arc)

    
    /** Target = unit */
    construct( unit targetUnit, real targetZOffset, vec3 originPos, boolean homing, string sfxPath, real speed, real arc  )
        initialize(originPos, targetPos, sfxPath, speed, arc)

        this.targetUnit = targetUnit

        if homing 
            action_preUpdate = () ->
                this.targetPos = this.targetUnit.getPos3with(targetZOffset)
                this.direction = this.pos.angleTo2d(this.targetPos).radians()
            
                this.velocity.x = Cos(this.direction) * this.speed
                this.velocity.y = Sin(this.direction) * this.speed

                this.missileSfx.setRoll(this.direction)


    private function initialize( vec3 originPos, vec3 targetPos, string sfx, real speed, real arc )
        
        this.originPos = originPos
        this.targetPos = targetPos
        this.speed = speed * ANIMATION_PERIOD
        this.direction = originPos.angleTo2d(targetPos).radians()

        velocity = vec3( Cos(direction) * this.speed,
                         Sin(direction) * this.speed,
                         Tan(arc) * this.speed          )

        pos = originPos
        missileSfx = addEffect( sfx, pos )
        ..setRoll( direction )

        startTimedLoop()



    ondestroy

        
        missileSfx.destr()
            

    override function onTimedLoop()
        update()

    function postUpdate()


    function update()

        if action_preUpdate != null
            action_preUpdate.run()


        real remainingDistance
        

        if distanceToTravel > 0
            remainingDistance = distanceToTravel - pos.distanceTo2d(originPos.toVec2()) 
        else
            remainingDistance = pos.toVec2().distanceTo(targetPos.toVec2())


        if speed >= remainingDistance
            
            if action_OnFinish != null

                action_OnFinish.run()


            destroy this
            return

        else
            let heightDif =  targetPos.z - pos.z
            let time = remainingDistance / speed
            let gravity = (2 / time) * (heightDif / time - velocity.z)

            velocity.z += gravity
            pos += velocity

            missileSfx.setPos(pos)

            let angle = Atan( velocity.z / speed )
            
            missileSfx.setPitch(-angle*Cos(direction))// * Sin(direction))
            missileSfx.setYaw(angle*Sin(direction))//) * )

            // Target collision
            if collisionEnabled
                let targets = ENUM_GROUP..enumUnitsInRange( pos.toVec2(), collisionRange )
                
                for target from targets

                    if (not collideOnce or not collidedUnits.contains(target)) and (collisionFilter == null or collisionFilter.filter(target))
                        onUnitCollision()
                        action_OnCollision.run(target)
                        collidedUnits.addUnit(target)
            



        
    function addPeriodicAction( real time )
        addPeriodicActionCounted(time, 0)

    function addPeriodicActionCounted( real time, int counts )


    function onUnitCollision()


    function addCollisionAction( real range, boolean is3d, boolean collideOnce, ProjectileFilter filter, MissileUnitAction action )      
        
        collisionEnabled = true
        collisionRange = range
        this.collideOnce = collideOnce
        action_OnCollision = action

        if collideOnce
            collidedUnits = CreateGroup()



    function addCollisionFilter(  )


    function addPreUpdateAction( MissileAction action )
        this.action_preUpdate = action

    function addOnFinishAction( MissileAction action )
        action_OnFinish = action
        
 
    function getPos() returns vec2
        return pos.toVec2()

    /** Sets the distance for the missile to travel. If not destroyed, it will travel exactly this distance. */
    function setDistance( real distance )
        distanceToTravel = distance


    // function getPos3() returns vec3
    //     return pos