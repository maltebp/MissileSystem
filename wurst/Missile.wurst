package Missile
import TimerUtils

    /*

        ProjectileTypes:
            - Unit Target
            - Unit Homing
            - Position

        Detections:
            - On hit (unit, position etc)
            - On Collision (perhaps using a filter function?)
    */


public interface MissileAction
    function run()


public interface MissileUnitAction
    function run(unit target)


public interface ProjectileFilter<T>
    function filter( T filterParam ) returns boolean


public class Missile

    use TimedLoop


    private vec3 pos
    private vec3 velocity

    protected effect missileSfx

    private vec3 targetPos 
    
    private real speed
    
    private ProjectileFilter<unit> collisionFilter = null
    
    private real collisionRange = 0

    private boolean collisionEnabled = false

    private boolean collideOnce = false

    private group collidedUnits = null

    private MissileUnitAction action_OnCollision = null

    private MissileAction action_OnFinish = null

    private real direction

    private unit targetUnit = null


    private real distanceToTravel = 0 // It will travel exactly this distanceToTravel

    private vec3 originPos

    protected MissileAction action_preUpdate = null
    protected MissileAction action_postUpdate = null


    /** Generic point */
    construct( vec3 originPos, vec3 targetPos, string sfxPath, real speed, real arc )
        initialize(originPos, targetPos, sfxPath, speed, arc)
    

    /** Target = unit */
    construct( unit targetUnit, real targetZOffset, vec3 originPos, boolean homing, string sfxPath, real speed, real arc  )
        initialize(originPos, targetPos, sfxPath, speed, arc)

        this.targetUnit = targetUnit

        if homing 
            action_preUpdate = () ->
                this.targetPos = this.targetUnit.getPos3with(targetZOffset)
                this.direction = this.pos.angleTo2d(this.targetPos).radians()
            
                this.velocity.x = Cos(this.direction) * this.speed
                this.velocity.y = Sin(this.direction) * this.speed

                this.missileSfx.setRoll(this.direction)


    private function initialize( vec3 originPos, vec3 targetPos, string sfx, real speed, real arc )
        
        this.originPos = originPos
        this.targetPos = targetPos
        this.speed = speed * ANIMATION_PERIOD
        this.direction = originPos.angleTo2d(targetPos).radians()

        velocity = vec3( Cos(direction) * this.speed,
                         Sin(direction) * this.speed,
                         Tan(arc) * this.speed          )

        pos = originPos
        missileSfx = addEffect( sfx, pos )
        ..setRoll( direction )

        startTimedLoop()



    ondestroy

        
        missileSfx.destr()
        


    override function onTimedLoop()

        if action_preUpdate != null
            action_preUpdate.run()
        
        let remainingDistance = (distanceToTravel > 0 ) ? distanceToTravel - pos.distanceTo2d(originPos.toVec2()) : pos.toVec2().distanceTo(targetPos.toVec2())

        if speed >= remainingDistance
            if action_OnFinish != null
                action_OnFinish.run()

            destroy this
            return

        else
            let heightDif =  targetPos.z - pos.z
            let time = remainingDistance / speed
            let gravity = (2 / time) * (heightDif / time - velocity.z)

            velocity.z += gravity
            pos += velocity

            missileSfx.setPos(pos)

            let angle = Atan( velocity.z / speed )
            
            missileSfx.setPitch(-angle*Cos(direction))// * Sin(direction))
            missileSfx.setYaw(angle*Sin(direction))//) * )


        if action_postUpdate != null
            action_postUpdate.run()


        
            

        
    function addPeriodicAction( real time )
        addPeriodicActionCounted(time, 0)

    function addPeriodicActionCounted( real time, int counts )


    function addCollisionAction( real range, boolean collideOnce, ProjectileFilter filter, MissileUnitAction action )      
        
        let collidedTargets = CreateGroup()

        action_postUpdate = ->
            let targets = ENUM_GROUP..enumUnitsInRange( this.pos.toVec2(), range )
                    
            for target from targets

                if (not collideOnce or not collidedTargets.contains(target)) and (this.collisionFilter == null or this.collisionFilter.filter(target))
                    action.run(target)
                    collidedTargets.addUnit(target)

        action_OnFinish = ->
            collidedTargets.destr()


    function addCollisionFilter(  )


    function addPreUpdateAction( MissileAction action )
        this.action_preUpdate = action

    function addOnFinishAction( MissileAction action )
        action_OnFinish = action
        
 
    function getPos() returns vec2
        return pos.toVec2()