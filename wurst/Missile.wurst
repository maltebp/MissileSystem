package Missile

import TimerUtils
import LinkedList
import ClosureTimers

/*
    HOW TO USE:
    Construct a new missile using any of the constructors. Then fire the missile using any of the
    fire methods.
*/



public interface MissileAction
    function run()


public interface MissileUnitAction
    function run(unit target)


public interface ProjectileFilter<T>
    function filter( T filterParam ) returns boolean


public class Missile

    private static let instances = new LinkedList<thistype>
    private static let updateTimer = getTimer() 

    private real updateFreq = 0

    private vec3 pos
    private vec3 velocity

    protected effect missileSfx

    private boolean finished = false

    private vec3 targetPos 
    
    private real speed
    
    private ProjectileFilter<unit> collisionFilter = null

    private LinkedList<MissileAction> actionsOnFinish = null

    private real direction

    private boolean destroyOnFinish = true

    private unit targetUnit = null
    private real targetZOffset = 0

    private boolean pitchEnabled = true

    private boolean homingEnabled = false
    
    private boolean arcEnabled = false

    private vec3 originPos

    protected MissileAction action_preUpdate = null
    protected MissileAction action_postUpdate = null

    private CallbackPeriodic updateCallback = null

    
    construct( vec3 originPos, string sfxPath )
        pos = originPos
        missileSfx = addEffect(sfxPath, pos)


    /** Hidden missiles */
    construct( vec3 originPos )
        pos = originPos

    function firePoint( vec3 targetPos, real speed, real arc )
        initialize( targetPos, speed, arc)

        if not arcEnabled
            doAfter( originPos.distanceTo(targetPos)/speed ) ->
                finish()
        

    function fireLine( vec3 targetPos, real distance, real speed )
        initialize( targetPos, speed, 0 )
        

        doAfter( distance/speed ) ->
            finish()



    function fireUnit(unit targetUnit, real targetZOffset, boolean homing, real speed, real arc)
        initialize( targetUnit.getPos3Real(), speed, arc)

        homingEnabled = homing

        this.targetUnit = targetUnit
        this.targetZOffset = targetZOffset


    /**   */
    private function initialize( vec3 targetPos, real speed, real arc )
        this.targetPos = targetPos
        this.speed = speed * ANIMATION_PERIOD
        this.direction = pos.angleTo2d(targetPos).radians()

        finished = false

        arcEnabled = arc > 0

        velocity = vec3( Cos(direction) * this.speed,
                         Sin(direction) * this.speed,
                         this.speed*4*arc          )
        // this.speed*4*arc is the adjustment which gives it the WC3 like arc
        
        missileSfx.setRoll( direction )

        startUpdate()




    ondestroy
        if actionsOnFinish != null
            for actionOnFinish in actionsOnFinish
                destroy actionOnFinish
            destroy actionsOnFinish

        missileSfx
        ..setYaw(0)
        ..setPitch(0)
        ..destr()

    


    
    function update()

        if action_preUpdate != null
            action_preUpdate.run()
        
        if homingEnabled
            this.targetPos = this.targetUnit.getPos3with(targetZOffset)
            this.direction = this.pos.angleTo2d(this.targetPos).radians()
        
            this.velocity.x = Cos(this.direction) * this.speed
            this.velocity.y = Sin(this.direction) * this.speed

            this.missileSfx.setRoll(this.direction)
            let remainingDistance = pos.toVec2().distanceTo(targetPos.toVec2())

            if speed >= remainingDistance
                //stopTimedLoop()
                finish()
                return


        if arcEnabled
            let remainingDistance = pos.toVec2().distanceTo(targetPos.toVec2())

            if speed >= remainingDistance
                //stopTimedLoop()
                finish()
                return

            else
                let heightDif =  targetPos.z - pos.z
                let time = remainingDistance / speed
                let gravity = (2 / time) * (heightDif / time - velocity.z)

                velocity.z += gravity

                if pitchEnabled
                    let angle = Atan( velocity.z / speed )
                    missileSfx.setPitch(-angle*Cos(direction))
                    missileSfx.setYaw(angle*Sin(direction))
            
        // Update position
        pos += velocity
        missileSfx.setPos(pos)

        if action_postUpdate != null
            action_postUpdate.run()


    function addCollisionAction( real range, boolean collideOnce, ProjectileFilter filter, MissileUnitAction action )      
        
        group collidedTargets = null

        if collideOnce
            collidedTargets = CreateGroup()
        action_postUpdate = ->
            let targets = ENUM_GROUP..enumUnitsInRange( this.pos.toVec2(), range )
                    
            for target from targets

                if (not collideOnce or not collidedTargets.contains(target)) and (this.collisionFilter == null or this.collisionFilter.filter(target))
                    action.run(target)
                    collidedTargets.addUnit(target)

        addActionOnFinish() ->
            collidedTargets.destr()
            destroy action


    private function startUpdate()
        if updateFreq > 0 // Checking for custom update freq
            updateCallback = doPeriodically( updateFreq ) cb ->
                this.update()
        else
            instances.add(this)
            if instances.size() == 1
                updateTimer.startPeriodic( ANIMATION_PERIOD ) ->
                    for instance in instances
                        instance.update()


    private function stopUpdate()
        if updateCallback != null
            destroy updateCallback
        else
            instances.remove(this)
            if instances.size() == 0
                updateTimer.pause()

    
    private function finish()
        finished = true

        stopUpdate()

        if actionsOnFinish != null
            for action in actionsOnFinish
                action.run()

        if destroyOnFinish and finished
            destroy this

        
    function addCollisionFilter(  )

    function addPreUpdateAction( MissileAction action )
        this.action_preUpdate = action

    function addActionOnFinish( MissileAction action )
        if actionsOnFinish == null
            actionsOnFinish = new LinkedList<MissileAction>
        actionsOnFinish.add(action)
        
 
    function getPos() returns vec2
        return pos.toVec2()

    function disablePitch()
        pitchEnabled = false

    function setUpdateFreq( real freq )
        updateFreq = (freq > 0) ? freq : 0

    function setPos( vec3 pos )
        this.pos = pos

    function getEffect() returns effect
        return null

            
    
    
    