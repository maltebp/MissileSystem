package Missile
import TimerUtils

    /*

        ProjectileTypes:
            - Unit Target
            - Unit Homing
            - Position

        Detections:
            - On hit (unit, position etc)
            - On Collision (perhaps using a filter function?)

    */


public interface MissileAction
    function run()


public interface MissileUnitAction
    function run(unit target)



public interface CollisionFilter
    function filter( unit filterUnit ) returns boolean


public class Missile

    private static let UPDATEFREQ = ANIMATION_PERIOD //ANIMATION_PERIOD

    private vec3 pos

    private vec3 velocity

    private real gravity

    protected effect missileSfx

    private timer updateTimer

    private vec3 targetPos 
    
    private real speed
    
    private CollisionFilter collisionFilter = null
    
    private real collisionRange = 0

    private boolean collisionEnabled = false

    private boolean collideOnce = false

    private group collidedUnits = null

    private MissileUnitAction action_OnCollision = null

    private MissileAction action_OnFinish = null

    private real direction

    private unit targetUnit = null

    private real zOffset = 0 // only used with unit target

    private boolean homing = false

    private real distanceToTravel = 0 // It will travel exactly this distanceToTravel

    private vec3 originPos

    
    


    construct( vec3 originPos, vec3 targetPos, string sfx, real speed, real arc )

        this.targetPos = targetPos
        this.originPos = originPos

        let distance = originPos.distanceTo(targetPos)
        let heightDif =  targetPos.z - originPos.z
        this.direction = originPos.angleTo2d(targetPos).radians()

        let adjustedSpeed = speed * UPDATEFREQ

        let time = distance
         / adjustedSpeed

        this.speed = adjustedSpeed

        velocity = vec3( Cos(direction) * adjustedSpeed,
                         Sin(direction) * adjustedSpeed,
                         Tan(arc) * adjustedSpeed
        )

        gravity =  (2 / time) * (heightDif / time - velocity.z)
        

        print("Gravity: "+gravity.toString(5))
        
        //(2*heightDif + 2*velocity.z * time ) / (time*time)
        
        //(Sin(2*arc) * velocity.length()*velocity.length()) / distanceToTravel

                              
        
        print(velocity.toString())

        pos = originPos

        missileSfx = addEffect( sfx, pos )
        ..setRoll(direction)

        // Timer
        updateTimer = getTimer()
        ..setData( this castTo int )
        ..startPeriodic( UPDATEFREQ, () -> GetExpiredTimer().getData() castTo thistype.update() ) 


    
    // Will always hit
    construct( unit targetUnit, real zOffset, vec3 originPos, boolean homing, string sfxPath, real speed, real arc  )

        this.targetUnit = targetUnit
        this.targetPos = targetUnit.getPos3with(zOffset)
        this.homing = homing
        this.originPos = originPos

        this.speed = speed * ANIMATION_PERIOD
        this.zOffset = zOffset

        this.direction = originPos.angleTo2d(targetPos).radians()
        
        velocity = vec3( Cos(direction) * this.speed,
                         Sin(direction) * this.speed,
                         Tan(arc) * this.speed
        )
        
        pos = originPos

        missileSfx = addEffect( sfxPath, pos )
        ..setRoll(direction)

        // Timer
        updateTimer = getTimer()
        ..setData( this castTo int )
        ..startPeriodic( UPDATEFREQ, () -> GetExpiredTimer().getData() castTo thistype.update() ) 



    ondestroy

        updateTimer.release()
        missileSfx.destr()
        


    function update()

        if homing and targetUnit != null
            targetPos = targetUnit.getPos3with(zOffset)
            direction = pos.angleTo2d(targetPos).radians()
        
            velocity.x = Cos(direction) * speed
            velocity.y = Sin(direction) * speed

            missileSfx.setRoll(direction)


        real remainingDistance
        

        if distanceToTravel > 0
            remainingDistance = distanceToTravel - pos.distanceTo2d(originPos.toVec2()) 
        else
            remainingDistance = pos.toVec2().distanceTo(targetPos.toVec2())


        if speed >= remainingDistance
            
            if action_OnFinish != null

                action_OnFinish.run()


            destroy this
            return

        else
            let heightDif =  targetPos.z - pos.z
            let time = remainingDistance / speed
            let gravity = (2 / time) * (heightDif / time - velocity.z)

            velocity.z += gravity
            pos += velocity

            missileSfx.setPos(pos)

            let angle = Atan( velocity.z / speed )
            
            missileSfx.setPitch(-angle*Cos(direction))// * Sin(direction))
            missileSfx.setYaw(angle*Sin(direction))//) * )

            // Target collision
            if collisionEnabled
                let targets = ENUM_GROUP..enumUnitsInRange( pos.toVec2(), collisionRange )
                
                for target from targets

                    if (not collideOnce or not collidedUnits.contains(target)) and (collisionFilter == null or collisionFilter.filter(target))
                        onUnitCollision()
                        action_OnCollision.run(target)
                        collidedUnits.addUnit(target)
            

    function onUpdate()
        

        
    function addPeriodicAction()


    function onUnitCollision()


    function addCollisionAction( real range, boolean is3d, boolean collideOnce, CollisionFilter filter, MissileUnitAction action )      
        
        collisionEnabled = true
        collisionRange = range
        this.collideOnce = collideOnce
        action_OnCollision = action

        if collideOnce
            collidedUnits = CreateGroup()



    function addCollisionFilter(  )


    function addOnFinishAction( MissileAction action )
        action_OnFinish = action
        
 
    function getPos() returns vec2
        return pos.toVec2()

    // function getPos3() returns vec3
    //     return pos


