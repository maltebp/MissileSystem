package Missile
import TimerUtils
import LinkedList
import ClosureTimers

/*
    [ ] Make adjustable updatefreq
    [ ] Have all missiles on regular update freq update together
*/




public interface MissileAction
    function run()


public interface MissileUnitAction
    function run(unit target)


public interface ProjectileFilter<T>
    function filter( T filterParam ) returns boolean



public class Missile

    use TimedLoop

    private real updateFreq = 0

    private vec3 pos
    private vec3 velocity

    protected effect missileSfx

    private vec3 targetPos 
    
    private real speed
    
    private ProjectileFilter<unit> collisionFilter = null

    private LinkedList<MissileAction> actionsOnFinish = null

    private real direction

    private boolean destroyOnFinish = true

    private unit targetUnit = null
    private real targetZOffset = 0

    private boolean pitchEnabled = true

    private boolean homingEnabled = false
    
    private boolean arcEnabled = false

    private vec3 originPos

    protected MissileAction action_preUpdate = null
    protected MissileAction action_postUpdate = null


    construct( vec3 originPos, string sfxPath )
        pos = originPos
        missileSfx = addEffect(sfxPath, pos)


    /** Hidden missiles */
    construct( vec3 originPos )
        pos = originPos

    /**   */
    private function initialize( vec3 targetPos, real speed, real arc )
        this.targetPos = targetPos
        this.speed = speed * ANIMATION_PERIOD
        this.direction = pos.angleTo2d(targetPos).radians()

        arcEnabled = arc > 0

        velocity = vec3( Cos(direction) * this.speed,
                         Sin(direction) * this.speed,
                         Tan(arc) * this.speed          )

        missileSfx.setRoll( direction )

        startTimedLoop()



    function firePoint( vec3 targetPos, real speed, real arc )
        initialize( targetPos, speed, arc)

        let missile = this

        if not arcEnabled
            doAfter( originPos.distanceTo(targetPos)/speed ) ->
                //missile.stopTimedLoopAndDestroy()
                destroy this
        

    function fireLine( vec3 targetPos, real distance, real speed )
        initialize( targetPos, speed, 0 )
    
        let missile = this

        doAfter( distance/speed ) ->
            print("destroy")
            destroy missile


    function fireUnit(unit targetUnit, real targetZOffset, boolean homing, real speed, real arc)
        initialize( targetUnit.getPos3Real(), speed, arc)

        homingEnabled = homing

        this.targetUnit = targetUnit
        this.targetZOffset = targetZOffset



    ondestroy    

        if actionsOnFinish != null
            for action in actionsOnFinish
                action.run()
                destroy action

            destroy actionsOnFinish

        missileSfx.destr()
    

    

    override function onTimedLoop()

        if action_preUpdate != null
            action_preUpdate.run()
        
        if homingEnabled
            this.targetPos = this.targetUnit.getPos3with(targetZOffset)
            this.direction = this.pos.angleTo2d(this.targetPos).radians()
        
            this.velocity.x = Cos(this.direction) * this.speed
            this.velocity.y = Sin(this.direction) * this.speed

            this.missileSfx.setRoll(this.direction)


        if arcEnabled
            print("...")
            let remainingDistance = pos.toVec2().distanceTo(targetPos.toVec2())

            if speed >= remainingDistance
                //stopTimedLoop()
                destroy this
                return

            else
                let heightDif =  targetPos.z - pos.z
                let time = remainingDistance / speed
                let gravity = (2 / time) * (heightDif / time - velocity.z)

                velocity.z += gravity

                if pitchEnabled
                    let angle = Atan( velocity.z / speed )
                    missileSfx.setPitch(-angle*Cos(direction))
                    missileSfx.setYaw(angle*Sin(direction))
            
        // Update position
        pos += velocity
        missileSfx.setPos(pos)

        if action_postUpdate != null
            action_postUpdate.run()



    function addCollisionAction( real range, boolean collideOnce, ProjectileFilter filter, MissileUnitAction action )      
        
        group collidedTargets = null

        if collideOnce
            collidedTargets = CreateGroup()
        action_postUpdate = ->
            let targets = ENUM_GROUP..enumUnitsInRange( this.pos.toVec2(), range )
                    
            for target from targets

                if (not collideOnce or not collidedTargets.contains(target)) and (this.collisionFilter == null or this.collisionFilter.filter(target))
                    action.run(target)
                    collidedTargets.addUnit(target)

        addActionOnFinish() ->
            collidedTargets.destr()
            destroy action


    function addCollisionFilter(  )


    function addPreUpdateAction( MissileAction action )
        this.action_preUpdate = action

    function addActionOnFinish( MissileAction action )
        if actionsOnFinish == null
            actionsOnFinish = new LinkedList<MissileAction>
        actionsOnFinish.add(action)
        
 
    function getPos() returns vec2
        return pos.toVec2()

    function disablePitch()
        pitchEnabled = false

    function setUpdateFreq( real freq )
        updateFreq = freq

    function setPos( vec3 pos )
        this.pos = pos
            
    
    
    